use abscissa_core::Runnable;
use age::{
    cli_common::{
        Passphrase,
        file_io::{OutputFormat, OutputWriter},
    },
    secrecy::ExposeSecret,
};
use std::io::Write;

use crate::{
    cli::{IdentityFileMode, InitWalletEncryptionCmd},
    commands::AsyncRunnable,
    components::{database::Database, keystore::KeyStore},
    error::{Error, ErrorKind},
    prelude::*,
};

impl AsyncRunnable for InitWalletEncryptionCmd {
    async fn run(&self) -> Result<(), Error> {
        let config = APP.config();
        let _lock = config.lock_datadir()?;

        let db = Database::open(&config).await?;
        let path = config
            .encryption_identity()
            .to_str()
            .ok_or_else(|| {
                ErrorKind::Init.context(format!(
                    "{} is not currently supported (not UTF-8)",
                    config.encryption_identity().display(),
                ))
            })?
            .to_string();

        generate_identity_file(&path, self.mode)?;

        let keystore = KeyStore::new(&config, db)?;

        // TODO: The following logic does not support plugin recipients, which can only be
        //       derived from identities by the plugins themselves.
        //       https://github.com/zcash/wallet/issues/252

        // If we have encrypted identities, it means the operator configured Zallet with
        // an encrypted identity file; obtain the recipients from it.
        let identity_file = match keystore
            .decrypt_identity_file(age::cli_common::UiCallbacks)
            .await?
        {
            Some(identity_file) => Ok(identity_file),
            _ => {
                // Re-read the identity file from disk.
                age::IdentityFile::from_file(path.to_string())
            }
        }
        .map_err(|e| ErrorKind::Generic.context(e))?;

        // Write out a recipients file, then parse it back into recipient strings.
        let mut recipients = vec![];
        identity_file
            .write_recipients_file(&mut recipients)
            .map_err(|e| ErrorKind::Generic.context(e))?;
        let recipient_strings = String::from_utf8(recipients)
            .map_err(|e| ErrorKind::Generic.context(e))?
            .lines()
            .map(String::from)
            .collect();

        // Store the recipients in the keystore.
        keystore.initialize_recipients(recipient_strings).await
    }
}

impl Runnable for InitWalletEncryptionCmd {
    fn run(&self) {
        self.run_on_runtime();
    }
}

/// Handles the creation of a new identity file, if necessary.
fn generate_identity_file(path: &str, mode: IdentityFileMode) -> Result<(), Error> {
    if matches!(mode, IdentityFileMode::UseExisting) {
        return Ok(());
    }

    let out = OutputWriter::new(
        Some(path.to_string()),
        false,
        OutputFormat::Text,
        0o600,
        false,
    )
    .map_err(|e| {
        ErrorKind::Init.context(format!("Failed to create encryption identity file: {}", e))
    })?;

    let sk = age::x25519::Identity::generate();
    let pk = sk.to_public();

    match mode {
        IdentityFileMode::CreateBasic => {
            let mut writer = out;
            writeln!(writer, "{}", sk.to_string().expose_secret())
                .map_err(|e| ErrorKind::Init.context(e))?;
        }
        IdentityFileMode::CreateWithPassphrase => {
            let passphrase = match age::cli_common::read_or_generate_passphrase() {
                Ok(Passphrase::Typed(p)) => p,
                Ok(Passphrase::Generated(p)) => {
                    // TODO: Not a big fan of this, at all. Is there a better
                    // way to log it that will capture more attention?
                    warn!("Using an autogenerated passphrase: {}", p.expose_secret());
                    warn!("Please store this passphrase securely.");
                    p
                }
                Err(e) => {
                    return Err(ErrorKind::Init
                        .context(format!("Failed to read or generate passphrase: {}", e))
                        .into());
                }
            };

            let encryptor = age::Encryptor::with_user_passphrase(passphrase);
            let mut writer = encryptor
                .wrap_output(out)
                .map_err(|e| ErrorKind::Init.context(e))?;

            writeln!(writer, "{}", sk.to_string().expose_secret())
                .map_err(|e| ErrorKind::Init.context(e))?;
            writer.finish().map_err(|e| ErrorKind::Init.context(e))?;
        }
        IdentityFileMode::UseExisting => unreachable!(),
    }

    info!("Encryption identity file created at {}", path);
    info!("Public key: {}", pk);
    Ok(())
}
