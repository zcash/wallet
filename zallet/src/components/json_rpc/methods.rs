use async_trait::async_trait;
use jsonrpsee::{
    core::{JsonValue, RpcResult},
    proc_macros::rpc,
};
use zaino_state::FetchServiceSubscriber;

use crate::components::{
    chain_view::ChainView,
    database::{Database, DbHandle},
};

#[cfg(zallet_build = "wallet")]
use {
    super::asyncop::{AsyncOperation, ContextInfo, OperationId},
    crate::components::keystore::KeyStore,
    serde::Serialize,
    tokio::sync::RwLock,
};

mod get_address_for_account;
#[cfg(zallet_build = "wallet")]
mod get_new_account;
#[cfg(zallet_build = "wallet")]
mod get_notes_count;
#[cfg(zallet_build = "wallet")]
mod get_operation;
mod get_raw_transaction;
#[cfg(zallet_build = "wallet")]
mod get_wallet_info;
#[cfg(zallet_build = "wallet")]
mod help;
mod list_accounts;
mod list_addresses;
#[cfg(zallet_build = "wallet")]
mod list_operation_ids;
mod list_transactions;
mod list_unified_receivers;
#[cfg(zallet_build = "wallet")]
mod list_unspent;
#[cfg(zallet_build = "wallet")]
mod lock_wallet;
#[cfg(zallet_build = "wallet")]
mod openrpc;
#[cfg(zallet_build = "wallet")]
mod recover_accounts;
mod stop;
#[cfg(zallet_build = "wallet")]
mod unlock_wallet;
mod view_transaction;
#[cfg(zallet_build = "wallet")]
mod z_get_total_balance;
#[cfg(zallet_build = "wallet")]
mod z_send_many;

/// The general JSON-RPC interface, containing the methods provided in all Zallet builds.
#[rpc(server)]
pub(crate) trait Rpc {
    #[method(name = "z_listaccounts")]
    async fn list_accounts(&self) -> list_accounts::Response;

    /// For the given account, derives a Unified Address in accordance with the remaining
    /// arguments:
    ///
    /// - If no list of receiver types is given (or the empty list `[]`), the best and
    ///   second-best shielded receiver types, along with the "p2pkh" (i.e. transparent)
    ///   receiver type, will be used.
    /// - If no diversifier index is given, then:
    ///   - If a transparent receiver would be included (either because no list of
    ///     receiver types is given, or the provided list includes "p2pkh"), the next
    ///     unused index (that is valid for the list of receiver types) will be selected.
    ///   - If only shielded receivers would be included (because a list of receiver types
    ///     is given that does not include "p2pkh"), a time-based index will be selected.
    ///
    /// The account parameter must be a UUID or account number that was previously
    /// generated by a call to the `z_getnewaccount` RPC method. The legacy account number
    /// is only supported for wallets containing a single seed phrase.
    ///
    /// Once a Unified Address has been derived at a specific diversifier index,
    /// re-deriving it (via a subsequent call to `z_getaddressforaccount` with the same
    /// account and index) will produce the same address with the same list of receiver
    /// types. An error will be returned if a different list of receiver types is
    /// requested, including when the empty list `[]` is provided (if the default receiver
    /// types don't match).
    #[method(name = "z_getaddressforaccount")]
    async fn get_address_for_account(
        &self,
        account: JsonValue,
        receiver_types: Option<Vec<String>>,
        diversifier_index: Option<u128>,
    ) -> get_address_for_account::Response;

    /// Lists the addresses managed by this wallet by source.
    ///
    /// Sources include:
    /// - Addresses generated from randomness by a legacy `zcashd` wallet.
    /// - Sapling addresses generated from the legacy `zcashd` HD seed.
    /// - Imported watchonly transparent addresses.
    /// - Shielded addresses tracked using imported viewing keys.
    /// - Addresses derived from mnemonic seed phrases.
    ///
    /// In the case that a source does not have addresses for a value pool, the key
    /// associated with that pool will be absent.
    ///
    /// REMINDER: It is recommended that you back up your wallet files regularly. If you
    /// have not imported externally-produced keys, it only necessary to have backed up
    /// the wallet's key storage file.
    #[method(name = "listaddresses")]
    async fn list_addresses(&self) -> list_addresses::Response;

    /// Returns a record of the individual receivers contained within the provided UA,
    /// keyed by receiver type. The UA may not have receivers for some receiver types,
    /// in which case those keys will be absent.
    ///
    /// Transactions that send funds to any of the receivers returned by this RPC
    /// method will be detected by the wallet as having been sent to the unified
    /// address.
    ///
    /// # Arguments
    /// - `unified_address` (string, required) The unified address to inspect.
    #[method(name = "z_listunifiedreceivers")]
    async fn list_unified_receivers(
        &self,
        unified_address: &str,
    ) -> list_unified_receivers::Response;

    /// Returns a list of the wallet's transactions, optionally filtered by account and block
    /// range.
    ///
    /// # Arguments
    /// - `account_uuid`: The UUID of the wallet account. If omitted, return transactions for all
    ///   accounts in the wallet.
    /// - `start_height`: The inclusive lower bound of block heights for which transactions mined
    ///   in those blocks should be returned. If omitted, the start height will default to the
    ///   account birthday height if an account UUID is specified, or the minimum birthday
    ///   height among accounts in the wallet if no account is specified.
    /// - `end_height`: The exclusive upper bound of block heights for which transactions mined
    ///   in those blocks should be returned. If omitted, return all transactions mined or created
    ///   above the start height.
    /// - `offset`: An optional number of transactions to skip over before a page of results is
    ///   returned. Defaults to zero.
    /// - `limit`: An optional upper bound on the number of results that should be returned in a
    ///   page.  
    ///
    /// WARNING: This is currently an experimental feature; arguments and result data may change at
    /// any time.
    #[method(name = "z_listtransactions")]
    async fn list_transactions(
        &self,
        account_uuid: Option<String>,
        start_height: Option<u32>,
        end_height: Option<u32>,
        offset: Option<u32>,
        limit: Option<u32>,
    ) -> list_transactions::Response;

    /// Returns the raw transaction data for the given transaction ID.
    ///
    /// NOTE: If `blockhash` is provided, only that block will be searched, and if the
    /// transaction is in the mempool or other blocks, or if the node backing this wallet
    /// does not have the given block available, the transaction will not be found.
    ///
    /// # Arguments
    /// - `txid` (string, required) The transaction ID.
    /// - `verbose` (numeric, optional, default=0) If 0, return a string of hex-encoded
    ///   data. If non-zero, return a JSON object with information about `txid`.
    /// - `blockhash` (string, optional) The block in which to look for the transaction.
    #[method(name = "getrawtransaction")]
    async fn get_raw_transaction(
        &self,
        txid: &str,
        // TODO: Bitcoin now also allows this to be named `verbosity`.
        verbose: Option<u64>,
        blockhash: Option<String>,
    ) -> get_raw_transaction::Response;

    /// Returns detailed information about in-wallet transaction `txid`.
    ///
    /// This method returns information about spends and outputs within the transaction
    /// that are visible to the wallet. Importantly, this does not include information
    /// about spent notes that are not controlled by spending or viewing keys in the
    /// wallet, and so callers MUST NOT use the `spends` or `outputs` fields to compute
    /// balances or fees themselves. Use the provided `accounts` and `fee` fields instead.
    #[method(name = "z_viewtransaction")]
    async fn view_transaction(&self, txid: &str) -> view_transaction::Response;

    /// Stop the running zallet process.
    ///
    /// # Notes
    ///
    /// - Works for non windows targets only.
    /// - Works only if the network of the running zallet process is `Regtest`.
    #[method(name = "stop")]
    async fn stop(&self) -> stop::Response;
}

/// The wallet-specific JSON-RPC interface, containing the methods only provided in the
/// wallet build of Zallet.
#[cfg(zallet_build = "wallet")]
#[rpc(server)]
pub(crate) trait WalletRpc {
    /// List all commands, or get help for a specified command.
    ///
    /// # Arguments
    /// - `command` (string, optional) The command to get help on.
    // TODO: Improve the build script so this works with non-wallet Zallet builds.
    #[method(name = "help")]
    fn help(&self, command: Option<&str>) -> help::Response;

    /// Returns an OpenRPC schema as a description of this service.
    // TODO: Improve the build script so this works with non-wallet Zallet builds.
    #[method(name = "rpc.discover")]
    fn openrpc(&self) -> openrpc::Response;

    /// Returns the list of operation ids currently known to the wallet.
    ///
    /// # Arguments
    /// - `status` (string, optional) Filter result by the operation's state e.g. "success".
    #[method(name = "z_listoperationids")]
    async fn list_operation_ids(&self, status: Option<&str>) -> list_operation_ids::Response;

    /// Get operation status and any associated result or error data.
    ///
    /// The operation will remain in memory.
    ///
    /// - If the operation has failed, it will include an error object.
    /// - If the operation has succeeded, it will include the result value.
    /// - If the operation was cancelled, there will be no error object or result value.
    ///
    /// # Arguments
    /// - `operationid` (array, optional) A list of operation ids we are interested in.
    ///   If not provided, examine all operations known to the node.
    #[method(name = "z_getoperationstatus")]
    async fn get_operation_status(&self, operationid: Vec<OperationId>) -> get_operation::Response;

    /// Retrieve the result and status of an operation which has finished, and then remove
    /// the operation from memory.
    ///
    /// - If the operation has failed, it will include an error object.
    /// - If the operation has succeeded, it will include the result value.
    /// - If the operation was cancelled, there will be no error object or result value.
    ///
    /// # Arguments
    /// - `operationid` (array, optional) A list of operation ids we are interested in.
    ///   If not provided, retrieve all finished operations known to the node.
    #[method(name = "z_getoperationresult")]
    async fn get_operation_result(&self, operationid: Vec<OperationId>) -> get_operation::Response;

    /// Returns wallet state information.
    #[method(name = "getwalletinfo")]
    async fn get_wallet_info(&self) -> get_wallet_info::Response;

    /// Stores the wallet decryption key in memory for `timeout` seconds.
    ///
    /// If the wallet is locked, this API must be invoked prior to performing operations
    /// that require the availability of private keys, such as sending funds.
    ///
    /// Issuing the `walletpassphrase` command while the wallet is already unlocked will
    /// set a new unlock time that overrides the old one.
    #[method(name = "walletpassphrase")]
    async fn unlock_wallet(
        &self,
        passphrase: age::secrecy::SecretString,
        timeout: u64,
    ) -> unlock_wallet::Response;

    /// Removes the wallet encryption key from memory, locking the wallet.
    ///
    /// After calling this method, you will need to call `walletpassphrase` again before
    /// being able to call any methods which require the wallet to be unlocked.
    #[method(name = "walletlock")]
    async fn lock_wallet(&self) -> lock_wallet::Response;

    /// Prepares and returns a new account.
    ///
    /// If the wallet contains more than one UA-compatible HD seed phrase, the `seedfp`
    /// argument must be provided. Available seed fingerprints can be found in the output
    /// of the `listaddresses` RPC method.
    ///
    /// Within a UA-compatible HD seed phrase, accounts are numbered starting from zero;
    /// this RPC method selects the next available sequential account number.
    ///
    /// Each new account is a separate group of funds within the wallet, and adds an
    /// additional performance cost to wallet scanning.
    ///
    /// Use the `z_getaddressforaccount` RPC method to obtain addresses for an account.
    #[method(name = "z_getnewaccount")]
    async fn get_new_account(
        &self,
        account_name: &str,
        seedfp: Option<&str>,
    ) -> get_new_account::Response;

    /// Tells the wallet to track specific accounts.
    ///
    /// Returns the UUIDs within this Zallet instance of the newly-tracked accounts.
    /// Accounts that are already tracked by the wallet are ignored.
    ///
    /// After calling this method, a subsequent call to `z_getnewaccount` will add the
    /// first account with index greater than all indices provided here for the
    /// corresponding `seedfp` (as well as any already tracked by the wallet).
    ///
    /// Each tracked account is a separate group of funds within the wallet, and adds an
    /// additional performance cost to wallet scanning.
    ///
    /// Use the `z_getaddressforaccount` RPC method to obtain addresses for an account.
    ///
    /// # Arguments
    ///
    /// - `accounts` (array, required) An array of JSON objects representing the accounts
    ///   to recover, with the following fields:
    ///   - `name` (string, required)
    ///   - `seedfp` (string, required) The seed fingerprint for the mnemonic phrase from
    ///     which the account is derived. Available seed fingerprints can be found in the
    ///     output of the `listaddresses` RPC method.
    ///   - `zip32_account_index` (numeric, required)
    ///   - `birthday_height` (numeric, required)
    #[method(name = "z_recoveraccounts")]
    async fn recover_accounts(
        &self,
        accounts: Vec<recover_accounts::AccountParameter<'_>>,
    ) -> recover_accounts::Response;

    /// Returns the total value of funds stored in the node's wallet.
    ///
    /// TODO: Currently watchonly addresses cannot be omitted; `include_watchonly` must be
    /// set to true.
    ///
    /// # Arguments
    ///
    /// - `minconf` (numeric, optional, default=1) Only include private and transparent
    ///   transactions confirmed at least this many times.
    /// - `include_watchonly` (bool, optional, default=false) Also include balance in
    ///   watchonly addresses (see 'importaddress' and 'z_importviewingkey').
    #[method(name = "z_gettotalbalance")]
    async fn z_get_total_balance(
        &self,
        minconf: Option<u32>,
        include_watchonly: Option<bool>,
    ) -> z_get_total_balance::Response;

    /// Returns an array of unspent shielded notes with between minconf and maxconf
    /// (inclusive) confirmations.
    ///
    /// Results may be optionally filtered to only include notes sent to specified
    /// addresses. When `minconf` is 0, unspent notes with zero confirmations are
    /// returned, even though they are not immediately spendable.
    ///
    /// # Arguments
    /// - `minconf`: Select outputs with at least this many confirmations (default = 1). Must be at
    ///   least 1 when `as_of_height` is provided.
    /// - `maxconf`: Select outputs with at most this many confirmations (default = unlimited).
    /// - `include_watchonly`: Include notes/utxos for which the wallet does not provide spending
    ///   capability (default = false).
    /// - `addresses`: A list of addresses for which to retrieve UTXOs. For shielded addresses that
    ///   correspond to a unified account, unspent notes belonging to that account are returned
    ///   irrespective of whether the provided address's diversifier corresponds to the diversifier
    ///   of the address that received the funds. If this parameter is omitted or empty, all notes
    ///   are returned, irrespective of account. (default = None)
    /// - `as_of_height`: Execute the query as if it were run when the blockchain was at the height
    ///   specified by this argument. The default is to use the entire blockchain that the node is
    ///   aware of. -1 can be used as in other RPC calls to indicate the current height (including
    ///   the mempool), but this does not support negative values in general. A “future” height will
    ///   fall back to the current height.
    #[method(name = "z_listunspent")]
    async fn list_unspent(
        &self,
        minconf: Option<u32>,
        maxconf: Option<u32>,
        include_watchonly: Option<bool>,
        addresses: Option<Vec<String>>,
        as_of_height: Option<i64>,
    ) -> list_unspent::Response;

    /// Returns the number of notes available in the wallet for each shielded value pool.
    ///
    /// # Arguments
    /// - `minconf`: Only include notes in transactions confirmed at least this many times
    ///   (default = 1). Must be at least 1 when `as_of_height` is provided.
    /// - `as_of_height`: Execute the query as if it were run when the blockchain was at the height
    ///   specified by this argument. The default is to use the entire blockchain that the node is
    ///   aware of. -1 can be used as in other RPC calls to indicate the current height (including
    ///   the mempool), but this does not support negative values in general. A “future” height will
    ///   fall back to the current height.
    #[method(name = "z_getnotescount")]
    async fn get_notes_count(
        &self,
        minconf: Option<u32>,
        as_of_height: Option<i64>,
    ) -> get_notes_count::Response;

    /// Send a transaction with multiple recipients.
    ///
    /// This is an async operation; it returns an operation ID string that you can pass to
    /// `z_getoperationstatus` or `z_getoperationresult`.
    ///
    /// Amounts are decimal numbers with at most 8 digits of precision.
    ///
    /// Change generated from one or more transparent addresses flows to a new transparent
    /// address, while change generated from a legacy Sapling address returns to itself.
    /// TODO: https://github.com/zcash/wallet/issues/138
    ///
    /// When sending from a unified address, change is returned to the internal-only
    /// address for the associated unified account.
    ///
    /// When spending coinbase UTXOs, only shielded recipients are permitted and change is
    /// not allowed; the entire value of the coinbase UTXO(s) must be consumed.
    /// TODO: https://github.com/zcash/wallet/issues/137
    ///
    /// # Arguments
    ///
    /// - `fromaddress` (string, required) The transparent or shielded address to send the
    ///   funds from. The following special strings are also accepted:
    ///   - `"ANY_TADDR"`: Select non-coinbase UTXOs from any transparent addresses
    ///     belonging to the wallet. Use `z_shieldcoinbase` to shield coinbase UTXOs from
    ///     multiple transparent addresses.
    ///   If a unified address is provided for this argument, the TXOs to be spent will be
    ///   selected from those associated with the account corresponding to that unified
    ///   address, from value pools corresponding to the receivers included in the UA.
    /// - `amounts` (array, required) An array of JSON objects representing the amounts to
    ///   send, with the following fields:
    ///   - `address` (string, required) A taddr, zaddr, or Unified Address.
    ///   - `amount` (numeric, required) The numeric amount in ZEC.
    ///   - `memo` (string, optional) If the address is a zaddr, raw data represented in
    ///     hexadecimal string format. If the output is being sent to a transparent
    ///     address, it’s an error to include this field.
    /// - `minconf` (numeric, optional) Only use funds confirmed at least this many times.
    /// - `fee` (numeric, optional) If set, it must be null. Zallet always uses a fee
    ///   calculated according to ZIP 317.
    /// - `privacy_policy` (string, optional, default=`"FullPrivacy"`) Policy for what
    ///   information leakage is acceptable. One of the following strings:
    ///   - `"FullPrivacy"`: Only allow fully-shielded transactions (involving a single
    ///     shielded value pool).
    ///   - `"AllowRevealedAmounts"`: Allow funds to cross between shielded value pools,
    ///     revealing the amount that crosses pools.
    ///   - `"AllowRevealedRecipients"`: Allow transparent recipients. This also implies
    ///     revealing information described under `"AllowRevealedAmounts"`.
    ///   - `"AllowRevealedSenders"`: Allow transparent funds to be spent, revealing the
    ///     sending addresses and amounts. This implies revealing information described
    ///     under `"AllowRevealedAmounts"`.
    ///   - `"AllowFullyTransparent"`: Allow transaction to both spend transparent funds
    ///     and have transparent recipients. This implies revealing information described
    ///     under `"AllowRevealedSenders"` and `"AllowRevealedRecipients"`.
    ///   - `"AllowLinkingAccountAddresses"`: Allow selecting transparent coins from the
    ///     full account, rather than just the funds sent to the transparent receiver in
    ///     the provided Unified Address. This implies revealing information described
    ///     under `"AllowRevealedSenders"`.
    ///   - `"NoPrivacy"`: Allow the transaction to reveal any information necessary to
    ///     create it. This implies revealing information described under
    ///     `"AllowFullyTransparent"` and `"AllowLinkingAccountAddresses"`.
    #[method(name = "z_sendmany")]
    async fn z_send_many(
        &self,
        fromaddress: String,
        amounts: Vec<z_send_many::AmountParameter>,
        minconf: Option<u32>,
        fee: Option<JsonValue>,
        privacy_policy: Option<String>,
    ) -> z_send_many::Response;
}

pub(crate) struct RpcImpl {
    wallet: Database,
    #[cfg(zallet_build = "wallet")]
    keystore: KeyStore,
    chain_view: ChainView,
}

impl RpcImpl {
    /// Creates a new instance of the general RPC handler.
    pub(crate) fn new(
        wallet: Database,
        #[cfg(zallet_build = "wallet")] keystore: KeyStore,
        chain_view: ChainView,
    ) -> Self {
        Self {
            wallet,
            #[cfg(zallet_build = "wallet")]
            keystore,
            chain_view,
        }
    }

    async fn wallet(&self) -> RpcResult<DbHandle> {
        self.wallet
            .handle()
            .await
            .map_err(|_| jsonrpsee::types::ErrorCode::InternalError.into())
    }

    async fn chain(&self) -> RpcResult<FetchServiceSubscriber> {
        self.chain_view
            .subscribe()
            .await
            .map(|s| s.inner())
            .map_err(|_| jsonrpsee::types::ErrorCode::InternalError.into())
    }
}

#[cfg(zallet_build = "wallet")]
pub(crate) struct WalletRpcImpl {
    general: RpcImpl,
    keystore: KeyStore,
    async_ops: RwLock<Vec<AsyncOperation>>,
}

#[cfg(zallet_build = "wallet")]
impl WalletRpcImpl {
    /// Creates a new instance of the wallet-specific RPC handler.
    pub(crate) fn new(wallet: Database, keystore: KeyStore, chain_view: ChainView) -> Self {
        Self {
            general: RpcImpl::new(wallet, keystore.clone(), chain_view),
            keystore,
            async_ops: RwLock::new(Vec::new()),
        }
    }

    async fn wallet(&self) -> RpcResult<DbHandle> {
        self.general.wallet().await
    }

    async fn chain(&self) -> RpcResult<FetchServiceSubscriber> {
        self.general.chain().await
    }

    async fn start_async<F, T>(&self, (context, f): (Option<ContextInfo>, F)) -> OperationId
    where
        F: Future<Output = RpcResult<T>> + Send + 'static,
        T: Serialize + Send + 'static,
    {
        let mut async_ops = self.async_ops.write().await;
        let op = AsyncOperation::new(context, f).await;
        let op_id = op.operation_id().clone();
        async_ops.push(op);
        op_id
    }
}

#[async_trait]
impl RpcServer for RpcImpl {
    async fn list_accounts(&self) -> list_accounts::Response {
        list_accounts::call(self.wallet().await?.as_ref())
    }

    async fn get_address_for_account(
        &self,
        account: JsonValue,
        receiver_types: Option<Vec<String>>,
        diversifier_index: Option<u128>,
    ) -> get_address_for_account::Response {
        get_address_for_account::call(
            self.wallet().await?.as_mut(),
            #[cfg(zallet_build = "wallet")]
            self.keystore.clone(),
            account,
            receiver_types,
            diversifier_index,
        )
        .await
    }

    async fn list_addresses(&self) -> list_addresses::Response {
        list_addresses::call(self.wallet().await?.as_ref())
    }

    async fn list_unified_receivers(
        &self,
        unified_address: &str,
    ) -> list_unified_receivers::Response {
        list_unified_receivers::call(self.wallet().await?.as_ref(), unified_address)
    }

    async fn list_transactions(
        &self,
        account_uuid: Option<String>,
        start_height: Option<u32>,
        end_height: Option<u32>,
        offset: Option<u32>,
        limit: Option<u32>,
    ) -> list_transactions::Response {
        list_transactions::call(
            self.wallet().await?.as_ref(),
            account_uuid,
            start_height,
            end_height,
            offset,
            limit,
        )
        .await
    }

    async fn get_raw_transaction(
        &self,
        txid: &str,
        verbose: Option<u64>,
        blockhash: Option<String>,
    ) -> get_raw_transaction::Response {
        get_raw_transaction::call(
            self.wallet().await?.as_ref(),
            self.chain().await?,
            txid,
            verbose,
            blockhash,
        )
        .await
    }

    async fn view_transaction(&self, txid: &str) -> view_transaction::Response {
        view_transaction::call(self.wallet().await?.as_ref(), self.chain().await?, txid).await
    }

    async fn stop(&self) -> stop::Response {
        stop::call(self.wallet().await?)
    }
}

#[cfg(zallet_build = "wallet")]
#[async_trait]
impl WalletRpcServer for WalletRpcImpl {
    fn help(&self, command: Option<&str>) -> help::Response {
        help::call(command)
    }

    fn openrpc(&self) -> openrpc::Response {
        openrpc::call()
    }

    async fn list_operation_ids(&self, status: Option<&str>) -> list_operation_ids::Response {
        list_operation_ids::call(&self.async_ops.read().await, status).await
    }

    async fn get_operation_status(&self, operationid: Vec<OperationId>) -> get_operation::Response {
        get_operation::status(&self.async_ops.read().await, operationid).await
    }

    async fn get_operation_result(&self, operationid: Vec<OperationId>) -> get_operation::Response {
        get_operation::result(self.async_ops.write().await.as_mut(), operationid).await
    }

    async fn get_wallet_info(&self) -> get_wallet_info::Response {
        get_wallet_info::call(&self.keystore).await
    }

    async fn unlock_wallet(
        &self,
        passphrase: age::secrecy::SecretString,
        timeout: u64,
    ) -> unlock_wallet::Response {
        unlock_wallet::call(&self.keystore, passphrase, timeout).await
    }

    async fn lock_wallet(&self) -> lock_wallet::Response {
        lock_wallet::call(&self.keystore).await
    }

    async fn get_new_account(
        &self,
        account_name: &str,
        seedfp: Option<&str>,
    ) -> get_new_account::Response {
        get_new_account::call(
            self.wallet().await?.as_mut(),
            &self.keystore,
            self.chain().await?,
            account_name,
            seedfp,
        )
        .await
    }

    async fn recover_accounts(
        &self,
        accounts: Vec<recover_accounts::AccountParameter<'_>>,
    ) -> recover_accounts::Response {
        recover_accounts::call(
            self.wallet().await?.as_mut(),
            &self.keystore,
            self.chain().await?,
            accounts,
        )
        .await
    }

    async fn z_get_total_balance(
        &self,
        minconf: Option<u32>,
        include_watchonly: Option<bool>,
    ) -> z_get_total_balance::Response {
        z_get_total_balance::call(self.wallet().await?.as_ref(), minconf, include_watchonly)
    }

    async fn list_unspent(
        &self,
        minconf: Option<u32>,
        maxconf: Option<u32>,
        include_watchonly: Option<bool>,
        addresses: Option<Vec<String>>,
        as_of_height: Option<i64>,
    ) -> list_unspent::Response {
        list_unspent::call(
            self.wallet().await?.as_ref(),
            minconf,
            maxconf,
            include_watchonly,
            addresses,
            as_of_height,
        )
    }

    async fn get_notes_count(
        &self,
        minconf: Option<u32>,
        as_of_height: Option<i64>,
    ) -> get_notes_count::Response {
        get_notes_count::call(self.wallet().await?.as_ref(), minconf, as_of_height)
    }

    async fn z_send_many(
        &self,
        fromaddress: String,
        amounts: Vec<z_send_many::AmountParameter>,
        minconf: Option<u32>,
        fee: Option<JsonValue>,
        privacy_policy: Option<String>,
    ) -> z_send_many::Response {
        Ok(self
            .start_async(
                z_send_many::call(
                    self.wallet().await?,
                    self.keystore.clone(),
                    self.chain().await?,
                    fromaddress,
                    amounts,
                    minconf,
                    fee,
                    privacy_policy,
                )
                .await?,
            )
            .await)
    }
}
